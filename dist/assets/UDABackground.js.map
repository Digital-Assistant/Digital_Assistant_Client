{"version":3,"file":"UDABackground.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AACA;AAAA;AAoBA;AAAA;AApBA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA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","sources":["webpack://UdanLibrary/./src/util/UDADigestMessage.ts","webpack://UdanLibrary/./src/util/invokeApi.ts","webpack://UdanLibrary/webpack/bootstrap","webpack://UdanLibrary/webpack/runtime/define property getters","webpack://UdanLibrary/webpack/runtime/hasOwnProperty shorthand","webpack://UdanLibrary/webpack/runtime/make namespace object","webpack://UdanLibrary/./src/Background.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/**\r\n *\r\n * @param textMessage\r\n * @param algorithm\r\n * @returns {Promise<ArrayBuffer>}\r\n * @constructor\r\n *\r\n * This is used for encrypting text messages as specified in the docs\r\n * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\r\n *\r\n */\r\nexport const UDADigestMessage = (textMessage, algorithm) => __awaiter(void 0, void 0, void 0, function* () {\r\n    const encoder = new TextEncoder();\r\n    const data = encoder.encode(textMessage);\r\n    const hash = yield crypto.subtle.digest(algorithm, data);\r\n    const hashArray = Array.from(new Uint8Array(hash)); // convert buffer to byte array\r\n    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string\r\n    return hashHex;\r\n});\r\n","/**\r\n * Common API call functionality\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nexport const invokeApi = (url, method, data, parseJson = true) => __awaiter(void 0, void 0, void 0, function* () {\r\n    try {\r\n        const config = {\r\n            method: method,\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'charset': 'UTF-8'\r\n            }\r\n        };\r\n        if (data) {\r\n            config.body = JSON.stringify(data);\r\n        }\r\n        const baseProdURL = process.env.baseProdURL;\r\n        const baseTestURL = process.env.baseTestURL;\r\n        let baseURL = baseProdURL;\r\n        if (url.indexOf(\"http\") === -1) {\r\n            if (UDAGlobalConfig.environment === 'TEST') {\r\n                baseURL = baseTestURL;\r\n            }\r\n            url = baseURL + url;\r\n        }\r\n        let response = yield fetch(url, config);\r\n        if (response.ok) {\r\n            if (parseJson) {\r\n                return response.json();\r\n            }\r\n            else {\r\n                return response.text();\r\n            }\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        return false;\r\n    }\r\n});\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","'use strict';\r\n\r\nimport {UDADigestMessage} from \"./util/UDADigestMessage\";\r\nimport {invokeApi} from \"./util/invokeApi\";\r\n\r\nlet UDADebug = false; //this variable exists in links.js file also\r\nconst apiHost = process.env.baseURL;\r\nconst cookieName = \"uda-sessiondata\";\r\nconst CSPStorageName = \"uda-csp-storage\";\r\nconst activeTabs = [];\r\nconst sessionKey = \"\";\r\nlet sessionData = {\r\n\tsessionkey: \"\",\r\n\tauthenticated: false,\r\n\tauthenticationsource: \"\",\r\n\tauthdata: {},\r\n\tcsp: {cspenabled: false, udanallowed: true, domain: ''}\r\n};\r\n\r\nlet currentTab = [];\r\n\r\n\r\nlet activeTabId;\r\n\r\n/**\r\n * Storing the active tab id to fetch for further data.\r\n */\r\nchrome.tabs.onActivated.addListener(function (activeInfo) {\r\n\tactiveTabId = activeInfo.tabId;\r\n});\r\n\r\n//login with chrome identity functionality\r\nasync function loginWithChrome() {\r\n\tsessionData.authenticationsource = \"google\";\r\n\tchrome.identity.getProfileUserInfo({accountStatus: 'ANY'}, async function (data) {\r\n\t\tif (data.id !== '' && data.email !== \"\") {\r\n\t\t\tsessionData.authenticated = true;\r\n\t\t\tsessionData.authdata = data;\r\n\t\t\tUDADigestMessage(sessionData.authdata.id, \"SHA-512\").then(async (encryptedid) => {\r\n\t\t\t\tsessionData.authdata.id = encryptedid;\r\n\t\t\t\tUDADigestMessage(sessionData.authdata.email, \"SHA-512\").then(async (encryptedemail) => {\r\n\t\t\t\t\tsessionData.authdata.email = encryptedemail;\r\n\t\t\t\t\tawait bindAuthenticatedAccount();\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tawait sendSessionData(\"UDAAlertMessageData\", \"login\")\r\n\t\t}\r\n\t});\r\n\treturn true;\r\n}\r\n\r\n//send the sessiondata to the webpage functionality\r\nasync function sendSessionData(sendaction = \"UDAUserSessionData\", message = '') {\r\n\tlet tab = await getTab();\r\n\tif (sendaction === \"UDAAlertMessageData\") {\r\n\t\tawait chrome.tabs.sendMessage(tab.id, {action: sendaction, data: message});\r\n\t\treturn true;\r\n\t} else {\r\n\t\tlet url = new URL(tab.url);\r\n\t\tlet domain = url.protocol + '//' + url.hostname;\r\n\t\tlet cspRecord = {cspenabled: false, udanallowed: true, domain: ''};\r\n\t\tlet cspData = getstoragedata(CSPStorageName);\r\n\t\tlet recordExists = false;\r\n\t\tif (cspData) {\r\n\t\t\tlet cspRecords = cspData;\r\n\t\t\tif (cspRecords.length > 0) {\r\n\t\t\t\tfor (let i = 0; i < cspRecords.length; i++) {\r\n\t\t\t\t\tif (cspRecords[i].domain === domain) {\r\n\t\t\t\t\t\trecordExists = true;\r\n\t\t\t\t\t\tcspRecord = cspRecords[i];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (recordExists) {\r\n\t\t\t\t\tsessionData.csp = cspRecord;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsessionData.csp = cspRecord;\r\n\t\tconsole.log(sessionData);\r\n\t\tawait chrome.tabs.sendMessage(tab.id, {action: sendaction, data: JSON.stringify(sessionData)});\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n *\r\n * @returns {currentTab}\r\n */\r\nasync function getTab() {\r\n\tlet queryOptions = {active: true, currentWindow: true};\r\n\tlet tab = (await chrome.tabs.query(queryOptions))[0];\r\n\t// let tab = await chrome.tabs.getCurrent();\r\n\tif (tab) {\r\n\t\treturn tab;\r\n\t} else {\r\n\t\ttab = await chrome.tabs.get(activeTabId);\r\n\t\tif (tab) {\r\n\t\t\treturn tab;\r\n\t\t} else {\r\n\t\t\tconsole.log('No active tab identified.');\r\n\t\t}\r\n\t}\r\n\treturn tab;\r\n}\r\n\r\n// listen for the requests made from webpage for accessing userdata\r\nchrome.runtime.onMessage.addListener(async function (request, sender, sendResponse) {\r\n\tconsole.log(request);\r\n\tif (request.action === \"getusersessiondata\") {\r\n\t\tchrome.storage.local.get([cookieName], async function (storedsessiondata) {\r\n\t\t\tif (chrome.runtime.lastError) {\r\n\t\t\t\tconsole.log('failed to read stored session data');\r\n\t\t\t} else {\r\n\t\t\t\t// looks like chrome storage might have changed so changing the reading the data has been changed. For to work with old version have added the new code to else if statement\r\n\t\t\t\tif (storedsessiondata.hasOwnProperty(\"sessionkey\") && storedsessiondata[\"sessionKey\"] && typeof storedsessiondata[\"sessionKey\"] != 'object') {\r\n\t\t\t\t\tsessionData = storedsessiondata;\r\n\t\t\t\t\tif(storedsessiondata.hasOwnProperty('authenticated') && storedsessiondata.authenticated) {\r\n\t\t\t\t\t\tawait sendSessionData();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tawait loginWithChrome();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (storedsessiondata.hasOwnProperty(cookieName) && storedsessiondata[cookieName].hasOwnProperty(\"sessionkey\") && storedsessiondata[cookieName][\"sessionKey\"] && typeof storedsessiondata[cookieName][\"sessionKey\"] != 'object') {\r\n\t\t\t\t\tsessionData = storedsessiondata[cookieName];\r\n\t\t\t\t\t// await sendSessionData();\r\n\t\t\t\t\tif(storedsessiondata.hasOwnProperty('authenticated') && storedsessiondata.authenticated) {\r\n\t\t\t\t\t\tawait sendSessionData();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tawait loginWithChrome();\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tawait getSessionKey(false);\r\n\t\t\t\t\tawait loginWithChrome();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t} else if (request.action === \"authtenicate\") {\r\n\t\tawait loginWithChrome();\r\n\t} else if (request.action === \"Debugvalueset\") {\r\n\t\tUDADebug = request.data;\r\n\t} else if (request.action === \"createSession\") {\r\n\t\tawait keycloakStore(request.data);\r\n\t}\r\n});\r\n\r\n//storing the data to the chrome storage\r\nasync function storeSessionData() {\r\n\tlet storageData = {};\r\n\tstorageData[cookieName] = sessionData;\r\n\tawait chrome.storage.local.set(storageData);\r\n\treturn true;\r\n}\r\n\r\n//getting the sessionkey from backend server\r\nasync function getSessionKey(senddata = true) {\r\n\tlet response = await invokeApi(apiHost + \"/user/getsessionkey\", \"GET\", null, false);\r\n\tconsole.log(response);\r\n\tif(!response){\r\n\t\treturn response;\r\n\t}\r\n\tsessionData.sessionkey = response;\r\n\tawait storeSessionData();\r\n\tif(senddata){\r\n\t\tawait sendSessionData();\r\n\t}\r\n\r\n}\r\n\r\n//binding the sessionkey and chrome identity id\r\nasync function bindAuthenticatedAccount() {\r\n\tlet authdata = {\r\n\t\tauthid: sessionData.authdata.id,\r\n\t\temailid: (sessionData.authdata.email)?sessionData.authdata.email:'',\r\n\t\tauthsource: sessionData.authenticationsource\r\n\t};\r\n\tlet response = await invokeApi(apiHost + \"/user/checkauthid\", \"POST\", authdata);\r\n\tif(response) {\r\n\t\tawait bindAccount(response);\r\n\t\treturn true;\r\n\t} else {\r\n\t\treturn response;\r\n\t}\r\n}\r\n\r\n//binding the session to the authid\r\nasync function bindAccount(userauthdata) {\r\n\tconst usersessiondata = {userauthid: userauthdata.id, usersessionid: sessionData.sessionkey};\r\n\tlet response = await invokeApi(apiHost + \"/user/checkusersession\", \"POST\", usersessiondata);\r\n\tawait storeSessionData();\r\n\tawait sendSessionData(\"UDAAuthenticatedUserSessionData\");\r\n\treturn true;\r\n}\r\n\r\nfunction CheckCSPStorage(cspenabled = false, udanallowed = false, domain) {\r\n\tconst csprecord = {cspenabled, udanallowed, domain};\r\n\tlet cspdata = getstoragedata(CSPStorageName);\r\n\tif (cspdata) {\r\n\t\tlet csprecords = cspdata;\r\n\t\tif (csprecords.length > 0) {\r\n\t\t\tlet recordexists = false;\r\n\t\t\tfor (let i = 0; i < csprecords.length; i++) {\r\n\t\t\t\tlet record = csprecords[i];\r\n\t\t\t\tif (record.domain === domain) {\r\n\t\t\t\t\trecordexists = true;\r\n\t\t\t\t\tcsprecords[i] = csprecord;\r\n\t\t\t\t\tcreatestoragedata(CSPStorageName, csprecords);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!recordexists) {\r\n\t\t\t\tcsprecords.push(csprecord);\r\n\t\t\t\tcreatestoragedata(CSPStorageName, csprecords);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcsprecords.push(csprecord);\r\n\t\t\tcreatestoragedata(CSPStorageName, csprecords);\r\n\t\t}\r\n\t} else {\r\n\t\tvar csprecords = [];\r\n\t\tcsprecords.push(csprecord);\r\n\t\tcreatestoragedata(CSPStorageName, csprecords);\r\n\t}\r\n}\r\n\r\nfunction createstoragedata(key, value) {\r\n\ttry {\r\n\t\tlocalStorage.setItem(key, JSON.stringify(value));\r\n\t\treturn true;\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nfunction getstoragedata(key) {\r\n\ttry {\r\n\t\tconst result = localStorage.getItem(key);\r\n\t\treturn JSON.parse(result);\r\n\t} catch (e) {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nfunction ProcessCSPValues(value = '', domain) {\r\n\tlet udanallowed = false;\r\n\tlet cspenabled = true;\r\n\tif (value) {\r\n\t\tlet allowedSrcs = value.split(\";\");\r\n\t\tif (allowedSrcs.length > 0) {\r\n\t\t\tfor (let i = 0; i < allowedSrcs.length; i++) {\r\n\t\t\t\tlet allowedSrc = allowedSrcs[i];\r\n\t\t\t\tlet allowedDomains = allowedSrc.split(' ');\r\n\t\t\t\tif (allowedDomains.length > 1 && allowedDomains[0].toLowerCase() === 'default-src') {\r\n\t\t\t\t\tfor (let index = 0; index < allowedDomains.length; index++) {\r\n\t\t\t\t\t\tlet allowedDomain = allowedDomains[index];\r\n\t\t\t\t\t\tif (allowedDomain === 'default-src') {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tswitch (allowedDomain.toLowerCase()) {\r\n\t\t\t\t\t\t\tcase '*':\r\n\t\t\t\t\t\t\tcase 'https:':\r\n\t\t\t\t\t\t\t\tudanallowed = true;\r\n\t\t\t\t\t\t\t\tcspenabled = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (allowedDomains.length > 0 && allowedDomains[0].toLowerCase() === 'default-src') {\r\n\t\t\t\t\tudanallowed = true;\r\n\t\t\t\t\tcspenabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tudanallowed = true;\r\n\t\tcspenabled = true;\r\n\t}\r\n\tCheckCSPStorage(cspenabled, udanallowed, domain);\r\n}\r\n\r\nlet onHeadersReceived = function (details) {\r\n\tlet url = new URL(details.url);\r\n\tconst domain = url.protocol + '//' + url.hostname;\r\n\tfor (let i = 0; i < details.responseHeaders.length; i++) {\r\n\t\tif (details.responseHeaders[i].name.toLowerCase() === 'content-security-policy') {\r\n\t\t\tProcessCSPValues(details.responseHeaders[i].value, domain);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nlet onHeaderFilter = {urls: ['*://*/*'], types: ['main_frame']};\r\n\r\n// commented the CSP checking code functionality\r\n/*chrome.declarativeNetRequest.onHeadersReceived.addListener(\r\n\tonHeadersReceived, onHeaderFilter, ['blocking', 'responseHeaders']\r\n);*/\r\n\r\n/**\r\n * Store keycloak data in chrome extension storage for retrival for other sites\r\n */\r\nasync function keycloakStore(data){\r\n\tconsole.log('creating session at extension');\r\n\tsessionData.authenticationsource = 'keycloak';\r\n\tsessionData.authenticated = true;\r\n\tsessionData.authdata = data;\r\n\tawait getSessionKey(false);\r\n\tawait bindAuthenticatedAccount();\r\n}\r\n\r\n"],"names":[],"sourceRoot":""}