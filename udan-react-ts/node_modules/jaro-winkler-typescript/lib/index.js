"use strict";
// Reference: https://www.geeksforgeeks.org/jaro-and-jaro-winkler-similarity/
Object.defineProperty(exports, "__esModule", { value: true });
exports.jaroWinkler = exports.jaro = void 0;
/**
 *
 * @param str1 String 1 for compare
 * @param str2 String 2 for compare
 * @param options to control case sensitive or not
 */
function jaro(str1, str2, options) {
    // Exit early if either are empty.
    if (str1.length === 0 || str2.length === 0) {
        return 0;
    }
    // Convert to upper if case-sensitive is false.
    if (options && !options.caseSensitive) {
        str1 = str1.toUpperCase();
        str2 = str2.toUpperCase();
    }
    // Exact match
    if (str1 === str2) {
        return 1;
    }
    // Number of matches
    var m = 0;
    // Length of two Strings
    var len1 = str1.length;
    var len2 = str2.length;
    // Maximum distance
    var window = Math.floor(Math.max(len1, len2) / 2) - 1;
    // Hash for matches
    var str1Hash = new Array(len1);
    var str2Hash = new Array(len2);
    for (var i = 0; i < len1; i++) {
        for (var j = Math.max(0, i - window); j <= Math.min(len2, i + window + 1); j++) {
            if (!str1Hash[i] && !str2Hash[j] && str1[i] === str2[j]) {
                ++m;
                str1Hash[i] = str2Hash[j] = true;
                break;
            }
        }
    }
    // Exit early if no matches were found.
    if (m === 0) {
        return 0;
    }
    // Count the transpositions.
    var t = 0;
    var point = 0;
    for (var i = 0; i < len1; i++) {
        if (str1Hash[i]) {
            while (!str2Hash[point]) {
                point++;
            }
            if (str1.charAt(i) !== str2.charAt(point++)) {
                t++;
            }
        }
    }
    t /= 2;
    return (m / len1 + m / len2 + (m - t) / m) / 3;
}
exports.jaro = jaro;
/**
 *
 * @param str1 String 1 for compare
 * @param str2 String 2 for compare
 * @param options to control case sensitive or not
 */
function jaroWinkler(str1, str2, options) {
    // Jaro Distance
    var jaroDist = jaro(str1, str2, options);
    // Same prefix length, maxium is 4
    var prefix = 0;
    if (jaroDist > 0.7) {
        var minIndex = Math.min(str1.length, str2.length);
        var i = 0;
        while (str1[i] === str2[i] && i < 4 && i < minIndex) {
            ++prefix;
            i++;
        }
        jaroDist += 0.1 * prefix * (1 - jaroDist);
    }
    return jaroDist;
}
exports.jaroWinkler = jaroWinkler;
