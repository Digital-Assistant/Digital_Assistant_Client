import ts from "typescript";
import { IProject } from "../transformers/IProject";
import { CheckerProgrammer } from "./CheckerProgrammer";
import { FunctionImporter } from "./helpers/FunctionImporeter";
import { IExpressionEntry } from "./helpers/IExpressionEntry";
export declare namespace IsProgrammer {
    const CONFIG: (options?: Partial<CONFIG.IOptions>) => CheckerProgrammer.IConfig;
    namespace CONFIG {
        interface IOptions {
            numeric: boolean;
            object: (entries: IExpressionEntry[]) => ts.Expression;
        }
    }
    function generate(project: IProject, modulo: ts.LeftHandSideExpression, equals?: boolean): (type: ts.Type) => ts.ArrowFunction;
    const generate_functors: (project: IProject, importer: FunctionImporter) => (collection: import("../factories/MetadataCollection").MetadataCollection) => ts.VariableStatement[];
    const generate_unioners: (project: IProject, importer: FunctionImporter) => (collection: import("../factories/MetadataCollection").MetadataCollection) => ts.VariableStatement[];
    const decode: (project: IProject, importer: FunctionImporter) => (input: ts.Expression, meta: import("../metadata/Metadata").Metadata, explore: CheckerProgrammer.IExplore, tags: import("../metadata/IMetadataTag").IMetadataTag[]) => ts.Expression;
    const decode_object: () => (input: ts.Expression, obj: import("../metadata/MetadataObject").MetadataObject, explore: CheckerProgrammer.IExplore) => ts.CallExpression;
    function decode_to_json(input: ts.Expression): ts.Expression;
    function decode_functional(input: ts.Expression): ts.BinaryExpression;
}
