import ts from "typescript";
import { MetadataCollection } from "../factories/MetadataCollection";
import { IMetadataTag } from "../metadata/IMetadataTag";
import { Metadata } from "../metadata/Metadata";
import { MetadataObject } from "../metadata/MetadataObject";
import { IProject } from "../transformers/IProject";
import { FunctionImporter } from "./helpers/FunctionImporeter";
import { IExpressionEntry } from "./helpers/IExpressionEntry";
export declare namespace FeatureProgrammer {
    interface IConfig {
        functors: string;
        unioners: string;
        path: boolean;
        trace: boolean;
        initializer: Initializer;
        decoder: Decoder<Metadata>;
        objector: IConfig.IObjector;
        generator?: Partial<IConfig.IGenerator>;
    }
    namespace IConfig {
        interface IObjector {
            checker: Decoder<Metadata>;
            decoder: Decoder<MetadataObject>;
            joiner: ObjectJoiner;
            unionizer: Decoder<MetadataObject[]>;
            failure: (value: ts.Expression, expected: string, explore?: IExplore) => ts.Statement;
            is?: (exp: ts.Expression) => ts.Expression;
            required?: (exp: ts.Expression) => ts.Expression;
            full?: (condition: ts.Expression) => (input: ts.Expression, expected: string, explore: IExplore) => ts.Expression;
        }
        interface IGenerator {
            functors(col: MetadataCollection): ts.VariableStatement[];
            unioners(col: MetadataCollection): ts.VariableStatement[];
        }
    }
    interface IExplore {
        tracable: boolean;
        source: "top" | "object";
        from: "top" | "array" | "object";
        postfix: string;
    }
    interface Initializer {
        (project: IProject, type: ts.Type): [MetadataCollection, Metadata];
    }
    interface Decoder<T> {
        (input: ts.Expression, target: T, explore: IExplore, tags: IMetadataTag[]): ts.Expression;
    }
    interface ObjectJoiner {
        (entries: IExpressionEntry[], parent: MetadataObject): ts.ConciseBody;
    }
    const generate: (project: IProject, config: IConfig, importer: FunctionImporter, addition: (collection: MetadataCollection) => ts.Statement[] | undefined) => (type: ts.Type) => ts.ArrowFunction;
    const generate_functors: (config: IConfig, importer: FunctionImporter) => (collection: MetadataCollection) => ts.VariableStatement[];
    const generate_unioners: (config: IConfig) => (collection: MetadataCollection) => ts.VariableStatement[];
    function decode_array(config: Pick<IConfig, "trace" | "path" | "decoder">, importer: FunctionImporter, combiner: (input: ts.Expression, arrow: ts.ArrowFunction, tags: IMetadataTag[]) => ts.Expression): (input: ts.Expression, meta: Metadata, explore: IExplore, tags: IMetadataTag[]) => ts.Expression;
    const decode_object: (config: Pick<IConfig, "trace" | "path" | "functors">) => (input: ts.Expression, obj: MetadataObject, explore: IExplore) => ts.CallExpression;
    const get_object_arguments: (config: Pick<IConfig, "path" | "trace">) => (explore: FeatureProgrammer.IExplore) => (input: ts.Expression) => ts.Expression[];
}
