"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterate_metadata_union = void 0;
var typescript_1 = __importDefault(require("typescript"));
var Metadata_1 = require("../../metadata/Metadata");
var Writable_1 = require("../../typings/Writable");
var TypeFactory_1 = require("../TypeFactory");
var iterate_metadata_1 = require("./iterate_metadata");
var iterate_metadata_union = function (checker) {
    return function (options) {
        return function (collection) {
            return function (meta, type, parentResolved) {
                var e_1, _a;
                if (!type.isUnion())
                    return false;
                else if (options.resolve === false || parentResolved === true) {
                    type.types.forEach(function (t) {
                        return (0, iterate_metadata_1.iterate_metadata)(checker)(options)(collection)(meta, t, false);
                    });
                    return true;
                }
                var filter = function (flag, t) {
                    return (t.getFlags() & flag) !== 0;
                };
                var normals = [];
                var toJsons = [];
                try {
                    for (var _b = __values(type.types), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var individual = _c.value;
                        if (filter(typescript_1.default.TypeFlags.Object, individual)) {
                            var resolved = TypeFactory_1.TypeFactory.resolve(checker, individual);
                            if (resolved !== null)
                                toJsons.push(resolved);
                            else
                                normals.push(individual);
                        }
                        else
                            normals.push(individual);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (toJsons.length !== 0) {
                    (0, Writable_1.Writable)(meta).resolved = (function () {
                        var union = Metadata_1.Metadata.initialize();
                        toJsons.forEach(function (t) {
                            return (0, iterate_metadata_1.iterate_metadata)(checker)(options)(collection)(meta, t, true);
                        });
                        if (union.objects.length > 1)
                            union.union_index = collection.getUnionIndex(union);
                        return union;
                    })();
                }
                normals.forEach(function (t) {
                    return (0, iterate_metadata_1.iterate_metadata)(checker)(options)(collection)(meta, t, false);
                });
                return true;
            };
        };
    };
};
exports.iterate_metadata_union = iterate_metadata_union;
//# sourceMappingURL=iterate_metadata_union.js.map