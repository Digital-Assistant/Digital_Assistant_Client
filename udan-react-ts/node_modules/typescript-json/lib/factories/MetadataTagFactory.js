"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataTagFactory = void 0;
var MetadataTagFactory;
(function (MetadataTagFactory) {
    function generate(identifier, metadata, tagList) {
        var e_1, _a;
        var output = [];
        try {
            for (var tagList_1 = __values(tagList), tagList_1_1 = tagList_1.next(); !tagList_1_1.done; tagList_1_1 = tagList_1.next()) {
                var tag = tagList_1_1.value;
                var elem = parse(identifier, metadata, tag, output);
                if (elem !== null)
                    output.push(elem);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tagList_1_1 && !tagList_1_1.done && (_a = tagList_1.return)) _a.call(tagList_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return output;
    }
    MetadataTagFactory.generate = generate;
    function parse(identifier, metadata, tag, output) {
        var _a;
        var closure = PARSER[tag.name];
        if (closure === undefined)
            return null;
        var text = (_a = (tag.text || [])[0]) === null || _a === void 0 ? void 0 : _a.text;
        if (text === undefined)
            throw new Error("".concat(LABEL, ": no tag value on ").concat(identifier()));
        return closure(identifier, metadata, text, output);
    }
})(MetadataTagFactory = exports.MetadataTagFactory || (exports.MetadataTagFactory = {}));
var PARSER = {
    items: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "items", "array", [
            "minItems",
            "maxItems",
        ]);
        return parse_range("items", identifier, text, true);
    },
    minItems: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "minItems", "array", ["items"]);
        return {
            kind: "minItems",
            value: parse_number(identifier, text),
        };
    },
    maxItems: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "maxItems", "array", ["items"]);
        return {
            kind: "maxItems",
            value: parse_number(identifier, text),
        };
    },
    type: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "type", "number", []);
        if (text !== "int" && text !== "uint")
            throw new Error("".concat(LABEL, ": invalid type tag on \"").concat(identifier(), "\"."));
        return { kind: "type", value: text };
    },
    range: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "range", "number", [
            "exclusiveMinimum",
            "minimum",
            "maximum",
            "exclusiveMaximum",
        ]);
        return parse_range("range", identifier, text, false);
    },
    minimum: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "minimum", "number", [
            "range",
            "exclusiveMaximum",
            "exclusiveMinimum",
        ]);
        return {
            kind: "minimum",
            value: parse_number(identifier, text),
        };
    },
    maximum: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "maximum", "number", [
            "range",
            "exclusiveMinimum",
            "exclusiveMaximum",
        ]);
        return {
            kind: "maximum",
            value: parse_number(identifier, text),
        };
    },
    exclusiveMinimum: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "exclusiveMinimum", "number", [
            "range",
            "minimum",
            "maximum",
        ]);
        return {
            kind: "exclusiveMinimum",
            value: parse_number(identifier, text),
        };
    },
    exclusiveMaximum: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "exclusiveMaximum", "number", [
            "range",
            "minimum",
            "maximum",
        ]);
        return {
            kind: "exclusiveMaximum",
            value: parse_number(identifier, text),
        };
    },
    multipleOf: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "multipleOf", "number", [
            "step",
        ]);
        return {
            kind: "multipleOf",
            value: parse_number(identifier, text),
        };
    },
    step: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "step", "number", [
            "multipleOf",
        ]);
        var minimum = output.some(function (tag) {
            return tag.kind === "minimum" ||
                tag.kind === "exclusiveMinimum" ||
                (tag.kind === "range" && tag.minimum !== undefined);
        });
        if (minimum === undefined)
            throw new Error("".concat(LABEL, ": step requires minimum tag on \"").concat(identifier(), "\"."));
        return {
            kind: "step",
            value: parse_number(identifier, text),
        };
    },
    format: function (identifier, metadata, value, output) {
        validate(identifier, metadata, output, "format", "string", ["pattern"]);
        if (FORMATS.has(value) === false)
            return null;
        return {
            kind: "format",
            value: value,
        };
    },
    pattern: function (identifier, metadata, value, output) {
        validate(identifier, metadata, output, "pattern", "string", ["format"]);
        return {
            kind: "pattern",
            value: value,
        };
    },
    length: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "length", "string", [
            "minLength",
            "maxLength",
        ]);
        return parse_range("length", identifier, text, true);
    },
    minLength: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "minLength", "string", [
            "length",
        ]);
        return {
            kind: "minLength",
            value: parse_number(identifier, text),
        };
    },
    maxLength: function (identifier, metadata, text, output) {
        validate(identifier, metadata, output, "maxLength", "string", [
            "length",
        ]);
        return {
            kind: "maxLength",
            value: parse_number(identifier, text),
        };
    },
};
function parse_range(kind, identifier, text, allowScalar) {
    if (allowScalar === true && Number.isNaN(Number(text)) === false) {
        var value = Number(text);
        if (Math.floor(value) !== value)
            throw new Error("".concat(LABEL, ": invalid length on \"").concat(identifier(), "\"."));
        return {
            kind: kind,
            minimum: {
                include: true,
                value: value,
            },
            maximum: {
                include: true,
                value: value,
            },
        };
    }
    else if (text.indexOf(",") === -1)
        if (LEFT_PARENTHESIS.some(function (str) { return text.indexOf(str) !== -1; }))
            return {
                kind: kind,
                minimum: parse_side("left")(kind)(identifier)(text),
            };
        else if (RIGHT_PARENTHESIS.some(function (str) { return text.indexOf(str) !== -1; }))
            return {
                kind: kind,
                maximum: parse_side("right")(kind)(identifier)(text),
            };
        else
            throw new Error("".concat(LABEL, ": invalid ").concat(kind, " tag on \"").concat(identifier(), "\"."));
    var _a = __read(text.split(","), 2), left = _a[0], right = _a[1];
    return {
        kind: kind,
        minimum: parse_side("left")(kind)(identifier)(left),
        maximum: parse_side("right")(kind)(identifier)(right),
    };
}
var parse_side = function (side) {
    var symbol = side === "left" ? LEFT_PARENTHESIS : RIGHT_PARENTHESIS;
    var substring = side === "left"
        ? function (str, index) { return str.substring(index + 1); }
        : function (str, index) { return str.substring(0, index); };
    return function (tag) { return function (identifier) { return function (text) {
        var _a = __read(text.indexOf(symbol[0]) !== -1
            ? [text.indexOf(symbol[0]), true]
            : [text.indexOf(symbol[1]), false], 2), index = _a[0], include = _a[1];
        if (index === -1)
            throw new Error("".concat(LABEL, ": invalid ").concat(tag, " tag on \"").concat(identifier(), "\"."));
        return {
            include: include,
            value: parse_number(identifier, substring(text, index)),
        };
    }; }; };
};
function parse_number(identifier, str) {
    var value = Number(str);
    if (isNaN(value) === true)
        throw new Error("".concat(LABEL, ": invalid number on \"").concat(identifier(), "\"."));
    return value;
}
var LABEL = "Error on TSON.MetadataTagFactory.generate()";
var LEFT_PARENTHESIS = ["[", "("];
var RIGHT_PARENTHESIS = ["]", ")"];
var FORMATS = new Set(["uuid", "email", "url", "mobile", "ipv4", "ipv6"]);
var WRONG_TYPE = function (tag, type, identifier) { return "".concat(LABEL, ": ").concat(tag, " requires ").concat(type, " type, but no \"").concat(identifier(), "\"."); };
function validate(identifier, metadata, output, kind, type, neighbors) {
    var e_2, _a;
    if (type === "array") {
        if (has_array(metadata) === false)
            throw new Error(WRONG_TYPE(kind, "array", identifier));
    }
    else if (has_atomic(metadata, type) === false)
        throw new Error(WRONG_TYPE(kind, type, identifier));
    if (output.some(function (tag) { return tag.kind === kind; }))
        throw new Error("".concat(LABEL, ": duplicated ").concat(kind, " tags on \"").concat(identifier(), "\"."));
    var _loop_1 = function (name_1) {
        if (output.some(function (tag) { return tag.kind === name_1; }))
            throw new Error("".concat(LABEL, ": ").concat(kind, " and ").concat(name_1, " tags on \"").concat(identifier(), "\"."));
    };
    try {
        for (var neighbors_1 = __values(neighbors), neighbors_1_1 = neighbors_1.next(); !neighbors_1_1.done; neighbors_1_1 = neighbors_1.next()) {
            var name_1 = neighbors_1_1.value;
            _loop_1(name_1);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (neighbors_1_1 && !neighbors_1_1.done && (_a = neighbors_1.return)) _a.call(neighbors_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
function has_atomic(metadata, type) {
    return (metadata.atomics.find(function (atom) { return atom === type; }) !== undefined ||
        metadata.arrays.some(function (child) { return has_atomic(child, type); }) ||
        metadata.tuples.some(function (tuple) {
            return tuple.some(function (child) { return has_atomic(child, type); });
        }));
}
function has_array(metadata) {
    return (metadata.arrays.length !== 0 ||
        metadata.tuples.some(function (tuple) { return tuple.some(function (child) { return has_array(child); }); }));
}
//# sourceMappingURL=MetadataTagFactory.js.map