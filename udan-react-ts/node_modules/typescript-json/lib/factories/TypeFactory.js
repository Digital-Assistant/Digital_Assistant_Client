"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeFactory = void 0;
var typescript_1 = __importDefault(require("typescript"));
var TypeFactory;
(function (TypeFactory) {
    function resolve(checker, type) {
        return get_return_type(checker, type, "toJSON");
    }
    TypeFactory.resolve = resolve;
    function isFunction(type) {
        return getFunction(type) !== null;
    }
    TypeFactory.isFunction = isFunction;
    function getFunction(type) {
        var _a, _b;
        var node = (_b = (_a = type.symbol) === null || _a === void 0 ? void 0 : _a.declarations) === null || _b === void 0 ? void 0 : _b[0];
        if (node === undefined)
            return null;
        return typescript_1.default.isFunctionLike(node)
            ? node
            : typescript_1.default.isPropertyAssignment(node) || typescript_1.default.isPropertyDeclaration(node)
                ? typescript_1.default.isFunctionLike(node.initializer)
                    ? node.initializer
                    : null
                : null;
    }
    function get_return_type(checker, type, name) {
        var symbol = type.getProperty(name);
        if (!symbol)
            return null;
        else if (!symbol.valueDeclaration)
            return null;
        var functor = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
        var signature = checker.getSignaturesOfType(functor, typescript_1.default.SignatureKind.Call)[0];
        return signature ? signature.getReturnType() : null;
    }
    function getFullName(checker, type) {
        var symbol = type.getSymbol() || type.aliasSymbol;
        if (symbol === undefined)
            return checker.typeToString(type, undefined, undefined);
        if (type.aliasSymbol === undefined && type.isUnionOrIntersection()) {
            var joiner = type.isIntersection() ? " & " : " | ";
            return type.types
                .map(function (child) { return getFullName(checker, child); })
                .join(joiner);
        }
        var name = get_name(symbol);
        var generic = checker.getTypeArguments(type);
        return generic.length
            ? name === "Promise"
                ? getFullName(checker, generic[0])
                : "".concat(name, "<").concat(generic
                    .map(function (child) { return getFullName(checker, child); })
                    .join(", "), ">")
            : name;
    }
    TypeFactory.getFullName = getFullName;
    function explore_name(name, decl) {
        return typescript_1.default.isModuleBlock(decl)
            ? explore_name("".concat(decl.parent.name.getText(), ".").concat(name), decl.parent.parent)
            : name;
    }
    function get_name(symbol) {
        return explore_name(symbol.escapedName.toString(), symbol.getDeclarations()[0].parent);
    }
})(TypeFactory = exports.TypeFactory || (exports.TypeFactory = {}));
//# sourceMappingURL=TypeFactory.js.map