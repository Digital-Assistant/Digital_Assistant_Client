"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const _1 = require(".");
describe("Profanity", () => {
    describe("exists (wholeWord = true)", () => {
        it("should return true when profanity exists in a sentence", () => {
            (0, chai_1.expect)(_1.profanity.exists("I like big butts and I cannot lie")).to.equal(true);
        });
        it("should return true when profanity exists as a single word", () => {
            (0, chai_1.expect)(_1.profanity.exists("butt")).to.equal(true);
        });
        it("should return false when profanity is not a whole word in a sentence", () => {
            (0, chai_1.expect)(_1.profanity.exists("Should we censor the word arsenic?")).to.equal(false);
        });
        it("should return true when profanity exists within multiple lines", () => {
            (0, chai_1.expect)(_1.profanity.exists(`
        Nothing profane on line 1.
        Censoring butt on line 2.
        Nothing profane on line 3.
      `)).to.equal(true);
        });
        it("should return false when profanity does not exist", () => {
            (0, chai_1.expect)(_1.profanity.exists("I like big glutes and I cannot lie")).to.equal(false);
        });
    });
    describe("exists (wholeWord = false)", () => {
        const options = new _1.ProfanityOptions();
        options.wholeWord = false;
        const customProfanity = new _1.Profanity(options);
        it("should return true when profanity is part of a word in a sentence", () => {
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word arsenic?")).to.equal(true);
        });
        it("should return true when profanity is part of a word, within multiple lines", () => {
            (0, chai_1.expect)(customProfanity.exists(`
        Nothing profane on line 1.
        Censoring arsenic on line 2.
        Nothing profane on line 3.
      `)).to.equal(true);
        });
        it("should return false when profanity does not exist", () => {
            (0, chai_1.expect)(customProfanity.exists("I like big glutes and I cannot lie")).to.equal(false);
        });
        it("should return true when profanity exists as part of a single word", () => {
            (0, chai_1.expect)(customProfanity.exists("arsenic")).to.equal(true);
        });
        it("Should return false when the last character is an 'A' with no profanity (A$$ edge case)", () => {
            (0, chai_1.expect)(customProfanity.exists("FUNTIMESA")).to.equal(false);
        });
        it("Should return true when the last character is an 'A' and there is profanity (A$$ edge case)", () => {
            (0, chai_1.expect)(customProfanity.exists("BUTTSA")).to.equal(true);
        });
        it("Should return true when some regex characters are present as profanity", () => {
            (0, chai_1.expect)(customProfanity.exists("lovea$$")).to.equal(true);
        });
    });
    describe("censor", () => {
        it("should replace profanity with grawlix in a sentence", () => {
            const censored = _1.profanity.censor("I like big butts and I cannot lie");
            (0, chai_1.expect)(censored.includes(_1.profanity.options.grawlix)).to.equal(true);
        });
        it("should remove profanity from a sentence", () => {
            const censored = _1.profanity.censor("I like big butts (aka arses) and I cannot lie");
            (0, chai_1.expect)(_1.profanity.exists(censored)).to.equal(false);
        });
        it("should remove profanity from multiple lines", () => {
            const censored = _1.profanity.censor(`
        Nothing profane on line 1.
        Censoring butt on line 2.
        Nothing profane on line 3.
      `);
            (0, chai_1.expect)(_1.profanity.exists(censored)).to.equal(false);
        });
        it("should not alter sentence without profanity", () => {
            const original = "I like big glutes and I cannot lie";
            const censored = _1.profanity.censor(original);
            (0, chai_1.expect)(censored).to.equal(original);
        });
        it("should remove profanity when profanity exists as a single word", () => {
            const censored = _1.profanity.censor("butt");
            (0, chai_1.expect)(_1.profanity.exists(censored)).to.equal(false);
        });
    });
    describe("addWords", () => {
        it("should add a single word to the list of profane words", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.addWords(["aardvark"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word aardvark?")).to.equal(true);
        });
        it("should add mulitple words to the list of profane words", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.addWords(["aardvark", "zebra"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word aardvark and zebra?")).to.equal(true);
        });
    });
    describe("removeWords", () => {
        it("should remove a single word from the list of profane words", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.removeWords(["butts"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts and I cannot lie")).to.equal(false);
        });
        it("should remove mulitple words from the list of profane words", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.removeWords(["butts", "arses"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts (aka arses) and I cannot lie")).to.equal(false);
        });
    });
    describe("Whitelist (wholeWord = true)", () => {
        it("should whitelist a single word", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.whitelist.addWords(["butt"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word butt?")).to.equal(false);
        });
        it("should whitelist multiple words", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.whitelist.addWords(["butt", "arse"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word butt or arse?")).to.equal(false);
        });
    });
    describe("Whitelist (wholeWord = false)", () => {
        const options = new _1.ProfanityOptions();
        options.wholeWord = false;
        it("should whitelist a single word", () => {
            const customProfanity = new _1.Profanity(options);
            customProfanity.whitelist.addWords(["buttocks"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word buttocks?")).to.equal(false);
        });
        it("should whitelist multiple words", () => {
            const customProfanity = new _1.Profanity(options);
            customProfanity.whitelist.addWords(["buttocks", "arsenic"]);
            (0, chai_1.expect)(customProfanity.exists("Should we censor the word buttocks or arsenic?")).to.equal(false);
        });
    });
    describe("Whitelist - removeWords", () => {
        it("should remove a single word from the whitelist", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.whitelist.addWords(["butts", "arses"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts and I cannot lie")).to.equal(false);
            customProfanity.whitelist.removeWords(["butts"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts and I cannot lie")).to.equal(true);
        });
        it("should remove multiple words from the whitelist", () => {
            const customProfanity = new _1.Profanity();
            customProfanity.whitelist.addWords(["butts", "arses"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts (aka arses) and I cannot lie")).to.equal(false);
            customProfanity.whitelist.removeWords(["butts"]);
            (0, chai_1.expect)(customProfanity.exists("I like big butts (aka arses) and I cannot lie")).to.equal(true);
        });
    });
});
//# sourceMappingURL=profanity.spec.js.map